void rl_clear_history (void) :
		Cancella l'elenco della cronologia eliminando tutte le voci, allo stesso modo della clear_history()funzione della libreria della cronologia.
		Ciò differisce dal clear_historyfatto che libera i dati privati ​​che Readline salva nell'elenco della cronologia.

void rl_replace_line (const char *text, int clear_undo) :
		Sostituisci il contenuto di rl_line_buffercon il testo . Il punto e il segno vengono conservati, se possibile.
		Se clear_undo è diverso da zero, l'elenco di annullamenti associato alla riga corrente viene cancellato.

void rl_redisplay (void) :
		Modifica ciò che viene visualizzato sullo schermo per riflettere il contenuto corrente di rl_line_buffer.

add_history (line) :
		Se si desidera che l'utente sia in grado di raggiungere la linea in un secondo momento ( C-pad esempio),
		è necessario chiamare add_history()per salvare la linea in un elenco cronologico di tali linee.

int access(const char *path, int amode) :
		La funzione access () controlla l'accessibilità del file denominato dal nome del percorso a cui punta l' argomento del percorso in base allo schema di bit contenuto in amode ,
		utilizzando l'ID utente reale al posto dell'ID utente effettivo e l'ID gruppo reale al posto di l'ID del gruppo effettivo.

int sigaction(int sig, const struct sigaction *__restrict__ nuovo, struct sigaction *__restrict__ vecchio) :
		Una sigaction() è una funzione che permette di chiamare/osservare o esaminare un'azione specifica associata a un particolare segnale.
		Si pensa di considerare una funzione di segnale e di sigla sulla stessa pagina. Ma in realtà non è successo.
		La funzione signal() non blocca altri segnali quando è in corso l'esecuzione del gestore corrente. Allo stesso tempo,
		la funzione sigaction può bloccare altri segnali fino al ritorno del gestore corrente
			https://linuxhint.com/c-sigaction-function-usage/#:~:text=A%20sigaction()%20is%20a,function%20on%20the%20same%20page.

int sigemptyset(sigset_t *set) :
		La funzione sigemptyset () inizializza il set di segnali puntato da set , in modo tale che tutti i segnali definiti in IEEE Std 1003.1-2001 siano esclusi.

int sigaddset(sigset_t *set, int signal) :
		Aggiunge un segnale all'insieme di segnali già registrati nell'insieme.

char *getcwd(char *buf, size_t size) :
		La funzione getcwd () inserisce un percorso assoluto della directory di lavoro corrente nell'array puntato da buf e restituisce buf .
		Il percorso copiato nell'array non deve contenere componenti che siano collegamenti simbolici.
		L' argomento size è la dimensione in byte dell'array di caratteri a cui punta l' argomento buf . Se buf è un puntatore nullo, il comportamento di getcwd () non è specificato.

int chdir(const char *percorso) :
		Il comando chdir è una funzione di sistema (chiamata di sistema) che viene utilizzata per modificare la directory di lavoro corrente.
		Su alcuni sistemi, questo comando viene utilizzato come alias per il comando della shell cd .
		chdir cambia la directory di lavoro corrente del processo chiamante nella directory specificata in path.

int stat(const char *restrict path, struct stat *restrict buf) :
		La funzione stat () deve ottenere informazioni sul file indicato e scriverle nell'area indicata dall'argomento buf.
		L' argomento percorso punta a un nome di percorso che nomina un file. Non è richiesta l'autorizzazione di lettura,
		scrittura o esecuzione del file indicato. Un'implementazione che fornisce meccanismi di controllo dell'accesso ai file aggiuntivi o alternativi può,
		in condizioni definite dall'implementazione, causare il fallimento di stat (). In particolare, il sistema può negare l'esistenza del file specificato da path
			https://pubs.opengroup.org/onlinepubs/009696799/functions/stat.html

int lstat(const char *restrict path, struct stat *restrict buf) :
		La funzione lstat () deve essere equivalente a stat () , tranne quando path fa riferimento a un collegamento simbolico.
		In tal caso lstat () restituirà informazioni sul collegamento, mentre stat () restituirà informazioni sul file a cui fa riferimento il collegamento.
			https://pubs.opengroup.org/onlinepubs/009696799/functions/lstat.html

int fstat(int fildes, struct stat *buf) :
		La funzione fstat () ottiene informazioni su un file aperto associato al descrittore di file fildes e le scrive nell'area indicata da buf .
			https://pubs.opengroup.org/onlinepubs/009696799/functions/fstat.html

int unlinkat(int fd, const char *path, int flag);
			https://pubs.opengroup.org/onlinepubs/9699919799/functions/unlink.html

int execve(const char * nomepercorso , char *const argv [], char *const envp []);
		In genere, quando si desidera eseguire un nuovo processo, non si desidera semplicemente
		un'altra copia dello stesso programma, ma si desidera eseguire un programma diverso.
		Ecco di cosa tratta la exec()chiamata di sistema. Sostituisce l'attuale programma in esecuzione con uno
		completamente nuovo. Ciò significa che quando chiami exec, il sistema operativo interrompe il processo,
		carica il nuovo programma e avvia quello al suo posto. Un processo non ritorna mai da una exec()chiamata
		(a meno che non si verifichi un errore).
			https://man7.org/linux/man-pages/man2/execve.2.html
			https://www.youtube.com/watch?v=iq7puCxsgHQ

int dup(int oldfd ) :
		scrive il testo passatogli nello stesso file aperto

int dup2(int oldfd , int newfd ) : 
		stesso funzionamento della dup() con la differenza che il testo passatogli puó essere
		scritto in un nuovo file

int pipe ( int pipefd [ 2 ] ) :
			https://www.geeksforgeeks.org/c-program-demonstrate-fork-and-pipe/

DIR *opendir(const char *dirname) :
		Apre la cartella passatagli
			https://pubs.opengroup.org/onlinepubs/009604599/functions/opendir.html

int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result) :
		La funzione readdir() restituisce un puntatore a una struttura che rappresenta la voce di directory nella posizione
		corrente nel flusso di directory specificato dall'argomento dirp e posiziona il flusso di directory alla voce successiva.
		Restituisce un puntatore nullo al raggiungimento della fine del flusso di directory.
		La struttura dirent definita dall'intestazione <direct.h> descrive una voce di directory.

int closedir(DIR *dirp) :
		La funzione closedir () chiude il flusso di directory a cui fa riferimento l'argomento dirp .
		Al momento della restituzione, il valore di dirp potrebbe non puntare più a un oggetto accessibile del tipo DIR .
		Se viene utilizzato un descrittore di file per implementare il tipo DIR ,
		tale descrittore di file deve essere chiuso.

char *strerror(int  errnum ) :
		Restituisce in dettaglio del codice di errore errno passatogli
			https://www.tutorialspoint.com/ansi_c/c_strerror.htm

void perror(const char *str) :
		Printa il dettaglio dell'errore generato da errno
			 https://www.tutorialspoint.com/c_standard_library/c_function_perror.html

int isatty(int fildes) :
			https://people.cs.rutgers.edu/~pxk/416/notes/c-tutorials/isatty.html

char * ttyname(int desc) :
		Restituisce il nome del terminale altrimenti ritorna NULL 
			https://ofstack.com/C++/10168/explain-the-usage-of-ttyname-of-function-and-isatty-of-function-in-c-language.html

int ttyslot(void) :
		Ritorna il percorso del termionale, da usare con le precedenti tty
			https://velog.io/@seungju0000/minishell-%ED%95%A8%EC%88%98%EC%99%80-%EC%BB%A4%EC%84%9C%EC%A0%9C%EC%96%B4

int ioctl(int fd , unsigned long request , ...) :
			https://linuxhint.com/c-ioctl-function-usage/

int ioctl(int fildes int cmd, ... /* arg */) :
		Oltre ai normali file di un sistema, ci sono alcuni file per scopi speciali, come i file del dispositivo.
		I file di dispositivo sono quelli utilizzati per interagire con i diversi driver di dispositivo di un sistema.
		Tuttavia, non è possibile accedere a questi file del dispositivo con l'aiuto di normali chiamate di sistema.
		È qui che entra in gioco la funzione “IOCTL”.
		Questa funzione aiuta ad accedere a questi file in modo molto conveniente.
		La funzione “IOCTL” del linguaggio di programmazione C risiede all'interno del file di intestazione “ioctl.h”.
			https://linuxhint.com/c-ioctl-function-usage/

char *getenv(const char *name) :
		La funzione della libreria C char *getenv(const char *name) cerca la stringa di ambiente
		a cui punta il nome e restituisce il valore associato alla stringa.
			https://www.tutorialspoint.com/c_standard_library/c_function_getenv.htm

int tcsetattr(int fd, int optional_actions, cons struct termios *termios_p) :
			https://www.man7.org/linux/man-pages/man3/termios.3.html

int tcgetattr(inf fd, struct termios *termios_p) :
			https://blog.naver.com/choi125496/130034222760
			https://velog.io/@seungju0000/minishell-%ED%95%A8%EC%88%98%EC%99%80-%EC%BB%A4%EC%84%9C%EC%A0%9C%EC%96%B4

int tgetent(char *bp, const char *name) :

char *tgoto(const char *cm, int col, int line);

char *tputs(const char *cp, int affcnt, int (*outc)(int));


terms.h
			https://www.gnu.org/software/termutils/manual/termcap-1.3/html_chapter/termcap_4.html#SEC23
			https://dev.to/tanishqsingla/termios-564j

Fonti varie
			https://velog.io/@seungju0000/minishell-%ED%95%A8%EC%88%98%EC%99%80-%EC%BB%A4%EC%84%9C%EC%A0%9C%EC%96%B4
			https://velog.io/@sham/minishell%EA%B3%BC-readline
			https://www.gnu.org/software/libc/manual/html_node/Mode-Functions.html#Mode-Functions
			https://www.gnu.org/software/bash/manual/bash.html
			https://brennan.io/2015/01/16/write-a-shell-in-c/
			https://www.gnu.org/software/libc/manual/html_node/Permission-Bits.html
			https://digilander.libero.it/uzappi/C/librerie/funzioni/open.html